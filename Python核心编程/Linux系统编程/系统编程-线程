######################################
线程实现多任务的方式
Threading对Tread做了封装

线程是进程里面真正来执行代码的东西
多个进程就是多个资源，进程是资源分配的单位，线程是CPU调度的单位，进程已经分配了资源模块，线程在里面运行

线程之间是相互不影响，多个线程在同一个函数中执行没有任何问题，但是资源是共享的

主进程要把子进程消耗的资源收回
僵尸进程：子进程已经结束，但是父进程并没有结束，在等着收回子进程所消耗的资源
孤儿进程：父进程已经结束了，但是子进程没有结束，之后1号进程为子进程收回其消耗资源
# 在linux操作系统中，0负责切换进程，1负责生进程

线程执行顺序 不确定 因为进程是有调度算法决定的，所以在进程中执行的子线程同样顺序不定
生成线程是按顺序生成的，但是调用取决于系统调度算法
# Python跨平台，因为安装环境本身屏蔽了底层硬件的差别，留给上层统一的接口。

多线程共享全局变量
线程和进程不一样，进程的资源是单独的，不共享数据，所以只能进程间通信，而线程运行是单独的，资源是共享的，是共享全局变量的
虽然线程不需要线程间通信，但是两个线程对同一个全局变量进行修改的时候会出现问题。
将列表当成实参传递给线程也可以

进程和线程之间的对比
进程：能够完成多任务，比如在一台电脑上能够同时运行多个qq
线程：能够完成多任务，比如一个qq中多个聊天窗口

# 原子操作(原子性)：要么不处理，一处理就处理到位

避免全局变量被修改的方式1：轮询 但是轮询操作效率并不高，因为轮询很占CPU资源
避免全局变量被修改的方式2：互斥锁
某个线程想要更改共享疏忽时，先将其锁定，此时资源的状态为锁定，其他线程不能更改；直到该线程释放资源，将需要的状态变成非锁定，其他的
线程才能再次锁定该资源，互斥锁保证了每次只有一个线程进行读写擦偶作，从而保证了多线程情况下数据的正确性











